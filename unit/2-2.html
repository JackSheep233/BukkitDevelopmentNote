<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>事件的监听 | Bukkit Development Note</title>
    <meta name="description" content="A guide to develop Minecraft Server plugins based on Bukkit.">
    <meta name="generator" content="VuePress 1.4.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.slim.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.js"></script>
  <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.css">
    
    <link rel="preload" href="/BukkitDevelopmentNote/assets/css/0.styles.306dc64a.css" as="style"><link rel="preload" href="/BukkitDevelopmentNote/assets/js/app.2634dd99.js" as="script"><link rel="preload" href="/BukkitDevelopmentNote/assets/js/2.cc6e75aa.js" as="script"><link rel="preload" href="/BukkitDevelopmentNote/assets/js/15.3d1313bf.js" as="script"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/10.e1cfcf7a.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/11.44efa5f5.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/12.3917c9a1.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/13.848a50a7.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/14.d3d0e1c2.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/16.4dd55a1e.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/17.ece6e639.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/18.ac97681d.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/19.396f060b.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/20.90cd3f0c.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/21.f6b39766.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/22.938c6544.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/23.f53b8e95.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/24.c4052a83.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/25.f7321946.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/26.548249ca.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/27.e2b64422.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/28.ed2628f6.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/29.1c742d23.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/3.c1f93749.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/30.04dcb996.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/31.b2bccbe9.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/32.6ab03692.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/33.222886c9.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/34.fe917ab1.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/35.c3502896.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/36.62f3d555.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/37.39042c08.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/38.d83a6a0c.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/4.2f54bf03.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/5.ec88f9e9.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/6.8d881c35.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/7.4444e5b6.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/8.4b9b39e0.js"><link rel="prefetch" href="/BukkitDevelopmentNote/assets/js/9.c2d8b702.js">
    <link rel="stylesheet" href="/BukkitDevelopmentNote/assets/css/0.styles.306dc64a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/BukkitDevelopmentNote/" class="home-link router-link-active"><!----> <span class="site-name">Bukkit Development Note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/BukkitDevelopmentNote/home.html" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/BukkitDevelopmentNote/contribute.html" class="nav-link">
  贡献
</a></div><div class="nav-item"><a href="https://alpha.tdiant.net/donate.html" target="_blank" rel="noopener noreferrer" class="nav-link external">
  赞助
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/tdiant/BukkitDevelopmentNote" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub仓库
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/BukkitDevelopmentNote/home.html" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/BukkitDevelopmentNote/contribute.html" class="nav-link">
  贡献
</a></div><div class="nav-item"><a href="https://alpha.tdiant.net/donate.html" target="_blank" rel="noopener noreferrer" class="nav-link external">
  赞助
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/tdiant/BukkitDevelopmentNote" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub仓库
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/BukkitDevelopmentNote/home.html" class="sidebar-link">欢迎</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第一部分: 基本概念</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/BukkitDevelopmentNote/unit/1-1.html" class="sidebar-link">写在前面</a></li><li><a href="/BukkitDevelopmentNote/unit/1-2.html" class="sidebar-link">MC的服务端介绍</a></li><li><a href="/BukkitDevelopmentNote/unit/1-3.html" class="sidebar-link">代码中的MC世界</a></li><li><a href="/BukkitDevelopmentNote/unit/1-4.html" class="sidebar-link">检索需要的信息</a></li><li><a href="/BukkitDevelopmentNote/unit/1-5.html" class="sidebar-link">服务端与客户端</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>第二部分: 基础内容</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/BukkitDevelopmentNote/unit/2-1.html" class="sidebar-link">最简单的插件</a></li><li><a href="/BukkitDevelopmentNote/unit/2-2.html" class="active sidebar-link">事件的监听</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/BukkitDevelopmentNote/unit/2-2.html#监听器-listener" class="sidebar-link">监听器(Listener)</a></li><li class="sidebar-sub-header"><a href="/BukkitDevelopmentNote/unit/2-2.html#理解客户端与服务端的关系" class="sidebar-link">理解客户端与服务端的关系</a></li><li class="sidebar-sub-header"><a href="/BukkitDevelopmentNote/unit/2-2.html#查询我们想了解的事件" class="sidebar-link">查询我们想了解的事件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/BukkitDevelopmentNote/unit/2-2.html#事件是怎么取名的" class="sidebar-link">事件是怎么取名的</a></li><li class="sidebar-sub-header"><a href="/BukkitDevelopmentNote/unit/2-2.html#可取消事件与不可取消事件怎么判断" class="sidebar-link">可取消事件与不可取消事件怎么判断</a></li><li class="sidebar-sub-header"><a href="/BukkitDevelopmentNote/unit/2-2.html#找到我们要找的事件" class="sidebar-link">找到我们要找的事件</a></li><li class="sidebar-sub-header"><a href="/BukkitDevelopmentNote/unit/2-2.html#并不是所有的事件都能监听" class="sidebar-link">并不是所有的事件都能监听.</a></li></ul></li><li class="sidebar-sub-header"><a href="/BukkitDevelopmentNote/unit/2-2.html#eventhandler注解的参数" class="sidebar-link">EventHandler注解的参数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/BukkitDevelopmentNote/unit/2-2.html#ignorecancelled" class="sidebar-link">ignoreCancelled</a></li></ul></li><li class="sidebar-sub-header"><a href="/BukkitDevelopmentNote/unit/2-2.html#监听器的注册" class="sidebar-link">监听器的注册</a></li><li class="sidebar-sub-header"><a href="/BukkitDevelopmentNote/unit/2-2.html#常用事件简介" class="sidebar-link">常用事件简介</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/BukkitDevelopmentNote/unit/2-2.html#登录、进入服务器" class="sidebar-link">登录、进入服务器</a></li><li class="sidebar-sub-header"><a href="/BukkitDevelopmentNote/unit/2-2.html#玩家移动" class="sidebar-link">玩家移动</a></li><li class="sidebar-sub-header"><a href="/BukkitDevelopmentNote/unit/2-2.html#玩家打开背包" class="sidebar-link">玩家打开背包</a></li></ul></li></ul></li><li><a href="/BukkitDevelopmentNote/unit/2-3.html" class="sidebar-link">配置API</a></li><li><a href="/BukkitDevelopmentNote/unit/2-4.html" class="sidebar-link">命令执行器</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第三部分: 进阶功能</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/BukkitDevelopmentNote/unit/3-2.html" class="sidebar-link">自定义事件</a></li><li><a href="/BukkitDevelopmentNote/unit/3-3.html" class="sidebar-link">深入plugin.yml</a></li><li><a href="/BukkitDevelopmentNote/unit/3-4.html" class="sidebar-link">配置API的序列化和遍历</a></li><li><a href="/BukkitDevelopmentNote/unit/3-5.html" class="sidebar-link">多线程多任务框架</a></li><li><a href="/BukkitDevelopmentNote/unit/3-6.html" class="sidebar-link">自定义合成表</a></li><li><a href="/BukkitDevelopmentNote/unit/3-7.html" class="sidebar-link">粒子效果和音效播放</a></li><li><a href="/BukkitDevelopmentNote/unit/3-8.html" class="sidebar-link">世界生成器</a></li><li><a href="/BukkitDevelopmentNote/unit/3-9.html" class="sidebar-link">Title、Bar与计分板显示</a></li><li><a href="/BukkitDevelopmentNote/unit/3-10.html" class="sidebar-link">经验和成就</a></li><li><a href="/BukkitDevelopmentNote/unit/3-11.html" class="sidebar-link">插件系统基本玩法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第四部分: 常用依赖</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/BukkitDevelopmentNote/unit/4-1.html" class="sidebar-link">Vault</a></li><li><a href="/BukkitDevelopmentNote/unit/4-2.html" class="sidebar-link">ProtocolLib</a></li><li><a href="/BukkitDevelopmentNote/unit/4-3.html" class="sidebar-link">Bungeecord</a></li><li><a href="/BukkitDevelopmentNote/unit/4-4.html" class="sidebar-link">PlaceholderAPI</a></li><li><a href="/BukkitDevelopmentNote/unit/4-5.html" class="sidebar-link">VexView</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第五部分: 底层部分</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/BukkitDevelopmentNote/unit/5-1.html" class="sidebar-link">认识NMS与OBC</a></li><li><a href="/BukkitDevelopmentNote/unit/5-2.html" class="sidebar-link">自定义发包</a></li><li><a href="/BukkitDevelopmentNote/unit/5-3.html" class="sidebar-link">NBT数据操作</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="事件的监听"><a href="#事件的监听" class="header-anchor">#</a> 事件的监听</h1> <p>事件是服务器里发生的事.<br>
例如, 天气的变化, 玩家的移动. 玩家把树打掉, 又捡起了掉落地上的原木. 这些都是事件.</p> <p>事件分为可控事件和不可控事件. 其最大区别在于能不能取消(<em>也就是能不能setCancelled</em>).<br>
不难理解, 玩家如果退出服务器, 这不能被取消, 它是不可控事件. 玩家的移动可以被取消, 它是可控事件.</p> <p>BukkitAPI给了一些基本的服务器事件. 大多数情况下可以满足我们的需求.<br>
本章以监听这些事件为例, 讲述事件的监听如何实现.</p> <h2 id="监听器-listener"><a href="#监听器-listener" class="header-anchor">#</a> 监听器(Listener)</h2> <p>监听器实质上是一个实现了<code>Listener</code>的类, 其中包含一些带有<code>@EventHandler</code>注解的方法.<br>
当服务器某个事件触发后, 例如玩家移动事件, 服务器就会创建一个对应的<code>PlayerMoveEvent</code>对象, 如果你的插件有注册并正在监听该事件的监听器, 那么服务端会按照<code>@EventHandler</code>注解找到对应的方法并调用, 你的插件因而便可监听到玩家移动事件了.</p> <p>我们以一个登录插件作为展开, 写一个“玩家不登录就不允许移动”的插件出来.<br>
因为截止到现在还没有说怎么注册命令, 这里我们设定玩家“只要右键空气就可以登录”.<br> <em>这里我们为了偷懒, 下面把主类直接实现<code>Listener</code>当做监听器用. 其实可以分开</em></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span> <span class="token keyword">extends</span> <span class="token class-name">JavaPlugin</span> <span class="token keyword">implements</span> <span class="token class-name">Listener</span><span class="token punctuation">{</span>
	<span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> playerNameList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//这是没登录玩家列表</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onEnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token class-name">Bukkit</span><span class="token punctuation">.</span><span class="token function">getPluginManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">registerEvents</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//这里HelloWorld类是监听器, 将当前HelloWorld对象注册监听器  </span>
    <span class="token punctuation">}</span>  
  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onDisable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  

	<span class="token comment">/*功能一：刚进入服务器的玩家都记录到“小本本”playerNameList上，他们是没登录的玩家*/</span>
	<span class="token annotation punctuation">@EventHandler</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onPlayerJoin</span><span class="token punctuation">(</span><span class="token class-name">PlayerJoinEvent</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//玩家登录服务器就会调用这个方法</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>playerNameList<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getPlayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//先判断这个玩家的名是不是记过了</span>
			playerNameList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getPlayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//玩家一登录就给他记上名, 代表他没登录</span>
	<span class="token punctuation">}</span>

	<span class="token comment">/*功能二：没登录的玩家不让移动*/</span>
    <span class="token annotation punctuation">@EventHandler</span> <span class="token comment">//这个注解告诉Bukkit这个方法正在监听某个事件</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onPlayerMove</span><span class="token punctuation">(</span><span class="token class-name">PlayerMoveEvent</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//玩家移动时Bukkit就会调用这个方法</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>playerNameList<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getPlayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		    e<span class="token punctuation">.</span><span class="token function">setCancelled</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//判断玩家是不是没登录, 是则取消事件</span>
    <span class="token punctuation">}</span>

	<span class="token comment">/*功能三：右击空气登录（本质就是从playerNameList把他删了）*/</span>
	<span class="token annotation punctuation">@EventHandler</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onPlayerInteract</span><span class="token punctuation">(</span><span class="token class-name">PlayerInteractEvent</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//玩家交互时会调用这个方法(这个下面会解释)</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token class-name">Action</span><span class="token punctuation">.</span>RIGHT_CLICK_AIR<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//判断是不是右键空气</span>
			playerNameList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getPlayerName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从上面的代码我们可以看出每一个事件都对应着一个<code>XXXEvent</code>对象. 事件类都以<code>Event</code>作为名称的结尾.</p> <p><strong>监听器类里由若干个带<code>@EventHandler</code>注解, 参数仅为一个<code>XXXEvent</code>的方法. 这些事件触发后会触发这些方法, 这就是事件监听的本质.</strong><br>
要特别注意, <strong>监听器中带有<code>@EventHandler</code>的方法一个只能监听某一个事件, 而不能监听多个事件!</strong> 换而言之, 这也就意味着, <strong>你不能填写两个参数, 实现一个方法同时监听两个事件的目的!</strong></p> <p>这里我们用到了玩家交互事件. 这个事件抽象不易理解.<br>
确切的来说, <code>PlayerInteractEvent</code>指的是玩家与方块交互, 交互指的是左右键方块的几乎一切操作. 具体的解释完全可以在JavaDoc中了解到.<br>
如果你曾经用过领地插件<code>Residence</code>, 你肯定对某个领地的权限<code>use</code>印象很深, 这个<code>use</code>权限与<code>PlayerInteractEvent</code>事件差不多, 可以近似认为<code>Residence</code>插件的<code>use</code>权限就是通过监听<code>PlayerInteractEvent</code>写出来的.</p> <p>要注意, <strong>监听器必须要注册才能算生效</strong>!<br>
我们的监听器里的方法都能监听到对应的事件的原因是, 在<code>onEnable</code>方法中, 我们写了这样的代码:</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Bukkit</span><span class="token punctuation">.</span><span class="token function">getPluginManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">registerEvents</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//这行代码注册了HelloWorld类为监听器, 如果没有这行代码, 下面所有带@EventHandler注解的方法都不会在事件触发时被调用！</span>
</code></pre></div><p><em>registerEvents方法的第一个参数是监听器，第二个参数是插件主类的实例. 在这里主类就是监听器. 具体你可以在后面了解到.</em></p> <h2 id="理解客户端与服务端的关系"><a href="#理解客户端与服务端的关系" class="header-anchor">#</a> 理解客户端与服务端的关系</h2> <p>如果你实际去使用上面的那个代码, 你可能会发现一个问题: 玩家移动在游戏里还可以移动, 但是一会儿会被服务器&quot;弹回来&quot;.<br>
这样确实是达到了取消玩家移动的目的, 但是, 为什么最终的效果不是&quot;玩家一点都动不了&quot;呢?</p> <p>事实上, 我们无法在服务端取消玩家一点也不能移动.<br>
客户端移动玩家时, 会在客户端显示出移动后的样子, 然后才会传递给服务器玩家移动的信号, 服务端收到客户端的信号后, 服务器才会触发<code>PlayerMoveEvent</code>事件, 做出响应.</p> <p>也就是说, 客户端与服务端之间, 客户端往往都是&quot;先斩后奏&quot;的. 客户端不管你服务端取不取消, 先那么显示出来再说.</p> <p><em>如果要是真的想实现让玩家在服务器的某个坐标一点也动不了, 也许需要发挥你的聪明才智了. 让玩家卡在一个透明方块里? 也许有更好的方案? 现在有人已经实现了!</em><br> <em>目前我们通常利用设置玩家移动速度的方法来让玩家无法移动!</em></p> <h2 id="查询我们想了解的事件"><a href="#查询我们想了解的事件" class="header-anchor">#</a> 查询我们想了解的事件</h2> <h3 id="事件是怎么取名的"><a href="#事件是怎么取名的" class="header-anchor">#</a> 事件是怎么取名的</h3> <p>你可以发现, 玩家移动<code>PlayerMoveEvent</code>、玩家进入服务器<code>PlayerJoinEvent</code>事件都有明显的特征.</p> <ol><li>功能决定名称, 看了名称你就能大致明白它的功能.</li> <li>都以<code>Event</code>作为结尾. 这也就说BukkitAPI中所有名字最后是<code>Event</code>的类都是事件类.</li> <li>开头的第一个词决定作用范围. 例如上面两个类开头都是<code>Player</code>, 这两个类都是与玩家有关的事件类.</li></ol> <p>所有的事件类都在<code>org.bukkit.event</code>包或其子包里.</p> <h3 id="可取消事件与不可取消事件怎么判断"><a href="#可取消事件与不可取消事件怎么判断" class="header-anchor">#</a> 可取消事件与不可取消事件怎么判断</h3> <p>例如<code>PlayerMoveEvent</code>在JavaDoc中, 我们可以注意到这些内容:</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PlayerMoveEvent</span>
<span class="token keyword">extends</span> <span class="token class-name">PlayerEvent</span>
<span class="token keyword">implements</span> <span class="token class-name">Cancellable</span>
</code></pre></div><p><code>PlayerMoveEvent</code>事件实现了<code>Cancellable</code>接口.<br> <code>Cancellable</code>中定义了<code>setCancelled</code>方法和<code>isCancelled</code>方法.<br>
通过<code>setCancelled</code>方法, 你可以在事件触发时设置是否取消该事件. 例如, 如果监听玩家移动, 事件触发时使用<code>setCancelled</code>方法, 可以取消玩家移动.<br> <code>isCancelled</code>方法可以判断该事件是否被取消.</p> <p>对于不可取消事件, 它们没有实现<code>Cancellable</code>接口, 因此它们无法被取消.<br>
就像玩家退出服务器, 你总不能像刀剑神域一样, 不让玩家退出服务器吧.</p> <p><em>值得注意的是, 如果玩家并没有改变他的X/Y/Z, 而只是利用鼠标转了一下身, 这也属于玩家移动, 仍会触发<code>PlayerMoveEvent</code>事件.</em></p> <h3 id="找到我们要找的事件"><a href="#找到我们要找的事件" class="header-anchor">#</a> 找到我们要找的事件</h3> <p>我们了解了如何监听事件, 那么我们想做到“不让玩家破坏方块”这个功能, 应该怎么做?<br>
思考后可以发现, 我们需要监听“方块被破坏”这个事件！那破坏方块后触发什么事件? 你需要在JavaDoc中找才能找到！</p> <p>分析: 破坏方块这个事件是一个与方块有关的事件. 打开JavaDoc你可以发现<code>BlockXXXXEvent</code>这类的类有许多.<br>
你也许会说, 玩家破坏方块为什么不是一个与玩家有关的事件呢？很有道理！你也可以在玩家事件中找找看有没有这样的事件.</p> <p>JavaDoc左侧上方是所有的包, 点击<code>org.bukkit.event.block</code>就能在左侧下方看所有与方块有关的事件了.<br>
你可以轻松地发现, 在前几个的位置迅速就能看到<code>BlockBreakEvent</code>, 根据名字就能判断出, 这就是你想找的方块破坏事件, 打开后看到描述为<code>Called when a block is broken by a player.</code>, 很明显, 监听它就对了.</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@EventHandler</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onBlockBreak</span><span class="token punctuation">(</span><span class="token class-name">BlockBreakEvent</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>
	e<span class="token punctuation">.</span><span class="token function">setCancelled</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样我们就写出了想要的功能.</p> <h3 id="并不是所有的事件都能监听"><a href="#并不是所有的事件都能监听" class="header-anchor">#</a> 并不是所有的事件都能监听.</h3> <p>在查阅JavaDoc时你可能发现<code>PlayerEvent</code>、<code>BlockEvent</code>这种事件.这些都是不可以被监听的事件.<br>
你不可以通过监听<code>PlayerEvent</code>事件来达到一次性监听所有与玩家有关的事件的目的.<br> <em>它们不能被监听的原因是没有做HandlerList. 在这里不多说明, 后面讲述如何自己做一个自定义事件时你会明白.</em></p> <p>一般来说，如果事件名由两个词构成(例如<code>PlayerEvent</code>)都不能监听, 大多数事件都可以监听.</p> <p>你可能好奇, 常见的登录插件都是把所有需要的玩家事件都写了<code>@EventHandler</code>注解方法一个个监听的？<br>
答案是, 的确如此. 你要想写登录插件, 你就应该去监听许许多多事件, 累也没办法, 就得这样写.</p> <h2 id="eventhandler注解的参数"><a href="#eventhandler注解的参数" class="header-anchor">#</a> EventHandler注解的参数</h2> <p>##监听优先级
想象一下, 如果有两个插件, 他们同时监听玩家移动. 其中一个插件判断后发现玩家没有充够450块钱, 于是它取消了这名玩家的移动. 但是另外一个插件判断后发现玩家非常帅, 于是它允许了这名玩家的移动.<br>
那么就会存在问题: 有一个插件<code>setCancelled(true)</code>, 而又有插件<code>setCancelled(false)</code>. 应该以谁为准?<br>
那就要看监听优先级了!</p> <p>下面是两个插件处理<code>PlayerMoveEvent</code>的部分:
A插件:</p> <div class="language-java extra-class"><pre class="language-java"><code>    <span class="token comment">// A插件</span>
	<span class="token annotation punctuation">@EventHandler</span><span class="token punctuation">(</span>priority<span class="token operator">=</span><span class="token class-name">EventPriority</span><span class="token punctuation">.</span>LOWEST<span class="token punctuation">)</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onPlayerMove</span><span class="token punctuation">(</span><span class="token class-name">PlayerMoveEvent</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>
	    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;testA&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	    e<span class="token punctuation">.</span><span class="token function">setCancelled</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre></div><p>B插件:</p> <div class="language-java extra-class"><pre class="language-java"><code>    <span class="token comment">// B插件</span>
	<span class="token annotation punctuation">@EventHandler</span><span class="token punctuation">(</span>priority<span class="token operator">=</span><span class="token class-name">EventPriority</span><span class="token punctuation">.</span>HIGHEST<span class="token punctuation">)</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onPlayerMove</span><span class="token punctuation">(</span><span class="token class-name">PlayerMoveEvent</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>
	    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;testB&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	    e<span class="token punctuation">.</span><span class="token function">setCancelled</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre></div><p>在实际的运行中, 当玩家移动时你会发现, 控制台中先输出了<code>testA</code>后输出了<code>testB</code>, 玩家都在服务器内可以自如移动.<br>
这意味着A插件第一个响应了玩家移动, 然后B插件才相应的玩家移动.<br> <code>@EventHandler</code>注解有一个成员叫做<code>priority</code>, 给他设置对应的<code>EventPriority</code>, 即可设置监听优先级. 在上面的例子中, Bukkit会在所有的LOWEST级监听被调用完毕后, 再去调用HIGHEST级监听.</p> <p><code>EventPriority</code>提供了五种优先级, 按照被调用顺序,为:<br>
LOWEST &lt; LOW &lt; NORMAL(如果你不设置, 默认就是它) &lt; HIGH &lt; HIGHEST &lt; MONITOR .<br>
其中, LOWEST最先被调用, 但对事件的影响最小. MONITOR最后被调用, 对事件的影响最大.</p> <h3 id="ignorecancelled"><a href="#ignorecancelled" class="header-anchor">#</a> ignoreCancelled</h3> <p><code>@EventHandler</code>注解除了<code>priority</code>之外, 还有<code>ignoreCancelled</code>. 如果不设置, 它默认为false.</p> <p>让我们回到上面的A插件与B插件的例子中. 我们把B插件的<code>onPlayerMove</code>改成这样:</p> <div class="language-java extra-class"><pre class="language-java"><code>    <span class="token comment">// B插件</span>
	<span class="token annotation punctuation">@EventHandler</span><span class="token punctuation">(</span>priority<span class="token operator">=</span><span class="token class-name">EventPriority</span><span class="token punctuation">.</span>HIGHEST<span class="token punctuation">,</span> ignoreCancelled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onPlayerMove</span><span class="token punctuation">(</span><span class="token class-name">PlayerMoveEvent</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>
	    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;testB&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	    e<span class="token punctuation">.</span><span class="token function">setCancelled</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre></div><p>可以发现, 后台只输出了<code>testA</code>, 玩家无法在服务器中移动. 这说明B插件的<code>onPlayerMove</code>没有被触发.<br>
如果有其他监听已经取消了该事件, 设置<code>ignoreCancelled</code>为<code>true</code>将可以忽略掉这个事件, 所以B插件的<code>onPlayerMove</code>方法没有被触发.</p> <h2 id="监听器的注册"><a href="#监听器的注册" class="header-anchor">#</a> 监听器的注册</h2> <p>可能你已经发现了, 在之前的代码中, 我们都会在<code>onEnable</code>方法中插入这样的语句:</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Bukkit</span><span class="token punctuation">.</span><span class="token function">getPluginManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">registerEvents</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
</code></pre></div><p>当时解释的是, <code>registerEvents</code>方法注册了该监听器.<br>
如果没有这样的注册语句, 那么Bukkit就不会在事件触发时调用监听器类的对应方法.</p> <p>该方法的第一个参数是监听器, 第二个参数是插件主类的实例. 当时由于我们为了偷懒, 直接把主类实现了<code>Listener</code>作为监听器, 因此我们可以这样写.<br>
可我们不能写插件的时候把代码都堆在主类中. 这也就意味着, 我们可以把其他类实现<code>Listener</code>, 用同样的方式注册它, 这样我们就可以把监听事件部分的代码放在别的地方, 使插件代码更有条理性.</p> <p>我们新创建一个类, 让它实现<code>Listener</code>, 再写对应的方法监听玩家移动, 就像这样:</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemoListener</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@EventHandler</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onPlayerMove</span><span class="token punctuation">(</span><span class="token class-name">PlayerMoveEvent</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>
	    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;PLAYER MOVE!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在我们在主类的<code>onEnable</code>方法里, 就可以注册它了!</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Bukkit</span><span class="token punctuation">.</span><span class="token function">getPluginManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">registerEvents</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DemoListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
</code></pre></div><h2 id="常用事件简介"><a href="#常用事件简介" class="header-anchor">#</a> 常用事件简介</h2> <p>这里可能罗列不会全面, 在我想到哪些“坑事件”后会列在这里.</p> <h3 id="登录、进入服务器"><a href="#登录、进入服务器" class="header-anchor">#</a> 登录、进入服务器</h3> <p>BukkitAPI中与登录有关的常见的有: <code>PlayerLoginEvent</code> <code>PlayerJoinEvent</code>.<br>
值得注意的是, 所有玩家进入服务器的事件都是不可取消事件.</p> <p>在玩家尝试连接服务器时, 会触发<code>PlayerLoginEvent</code>, 玩家完全地进入服务器后, 会触发<code>PlayerJoinEvent</code>.<br>
在<code>PlayerLoginEvent</code>触发的时候, 你不可以操控玩家<code>Player</code>对象获取其背包等信息, 而仅可以获取UUID、玩家名和网络信息(IP等)等.<br>
*顺便一提, 玩家如果不在线, 你不可以通过BukkitAPI操控其背包.  *
<code>PlayerJoinEvent</code>触发时, 服务器内将会出现玩家实体. 此时你可以当做玩家完全进入服务器, 对其自由操作.</p> <p>打个比方, 你家有一扇防盗门, 有人想进入你家.<br>
首先他需要敲门, 在门外喊出自己的基本信息(名字等), 这是<code>PlayerLoginEvent</code>触发的时候. 如果你想从他背包里拿出东西, 不可以, 因为他在门外面.<br>
当你给他打开门, 他进了你家中站稳了以后, 这是<code>PlayerJoinEvent</code>触发的时候, 这时候不管你是想打他还是想拿走他的东西, 都可以.</p> <h3 id="玩家移动"><a href="#玩家移动" class="header-anchor">#</a> 玩家移动</h3> <p>在上面我们已经提及过, 玩家移动是“先斩后奏”被触发的. 具体请见上文.</p> <h3 id="玩家打开背包"><a href="#玩家打开背包" class="header-anchor">#</a> 玩家打开背包</h3> <p>也许你会看到<code>InventoryOpenEvent</code>. 根据描述你大概明白, 类似右击箱子后出现的那种带格子的界面被打开可以被监听.<br>
但是有一件事很重要: 玩家按E打开背包是没办法被监听的.</p> <p>一般如果要实现禁止玩家打开背包, 其实最常规的做法就是开一个<code>BukkitRunnable</code>, 定时调用<code>p.closeInventory()</code>关闭玩家正在打开的背包实现的.<br> <em>这里不详细讲述具体如何操作, 感兴趣可以在QQ群中问一些有经验的开发者.</em><br> <em>后面会讲述Runnable, 也许看后你会明白如何操作.</em></p> <p>感兴趣可以看看这个帖子: https://www.mcbbs.net/thread-965760-1-1.html</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/BukkitDevelopmentNote/unit/2-1.html" class="prev">
        最简单的插件
      </a></span> <span class="next"><a href="/BukkitDevelopmentNote/unit/2-3.html">
        配置API
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/BukkitDevelopmentNote/assets/js/app.2634dd99.js" defer></script><script src="/BukkitDevelopmentNote/assets/js/2.cc6e75aa.js" defer></script><script src="/BukkitDevelopmentNote/assets/js/15.3d1313bf.js" defer></script>
  </body>
</html>
